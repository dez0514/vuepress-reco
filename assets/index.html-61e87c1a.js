import{_ as n,p as a,q as s,J as e}from"./framework-4a7f5a2b.js";const t={},p=e(`<h2 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h2><p>单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单</p><h3 id="jsx" tabindex="-1"><a class="header-anchor" href="#jsx" aria-hidden="true">#</a> jsx</h3><p>React 使用 JSX 来替代常规的 JavaScript，JSX 是一个看起来很像 XML 的 JavaScript 语法扩展，其实就是将js和html结合起来书写。</p><h3 id="class组件生命周期" tabindex="-1"><a class="header-anchor" href="#class组件生命周期" aria-hidden="true">#</a> class组件生命周期</h3><ol><li>初始化阶段 initialization, 比如constructor</li><li>组件挂载阶段 mount</li></ol><ul><li>componentWillMount 组件挂载到DOM前调用,只会被调用一次, 这里写setState不会引起组件重新渲染</li><li>render 返回一个react元素, react根据此函数的返回值渲染DOM. 不能在这里setState</li><li>componentDidMount 组件挂载到DOM后调用, 且只会被调用一次</li></ul><ol start="3"><li>更新阶段 update</li></ol><ul><li>componentWillReceiveProps(nextProps) 触发于props引起的组件更新过程中</li><li>shouldComponentUpdate(nextProps, nextState) 比较之前和当前的props state是否有变化</li><li>componentWillUpdate(nextProps, nextState) render方法前执行</li><li>render</li><li>componentDidUpdate(preProps, preState) 4.卸载阶段 unmount</li><li>componentWillUnmount 卸载前调用, 在这里可以清理一些定时器</li></ul><h3 id="事件机制" tabindex="-1"><a class="header-anchor" href="#事件机制" aria-hidden="true">#</a> 事件机制：</h3><p>答 ：React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。 另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。</p><h3 id="hooks" tabindex="-1"><a class="header-anchor" href="#hooks" aria-hidden="true">#</a> Hooks</h3><p>规则限制: 只在React最顶层使用，不能在循环，条件，或者嵌套函数中使用。指的是 useXXX 不能在if中使用，不是指定义的 setXXX 方法不能在if中使用。 基础： useState, useEffect, useContext 额外的：useReducer, useCallback, useMemo, useRef, useImperativeHandle, useLayoutEffect, useDebugValue</p><ol><li>常用的用法：useReducer + useContext， 利用二者结合来实现<code>局部</code>中的全局数据管理。效果类似 redux。</li><li>useMemo： 类似vue的计算属性computed，返回一个 memoized 值。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// a, b 为依赖项，当依赖项变化时才会变化，否则使用缓存的</span>
<span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>useCallback：缓存函数。返回一个 memoized 回调函数。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// a, b 为依赖项，当依赖项变化时才会变化，否则使用缓存的</span>
<span class="token keyword">const</span> memoizedCallback <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>useImperativeHandle：类似于vue3的defineExpose， 暴露出子组件，在父组件调用ref, 来调用子组件的方法。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 用法： useImperativeHandle(ref, createHandle, [deps])</span>
<span class="token comment">// useImperativeHandle 可以在使用 ref 时自定义暴露给父组件的实例值。</span>
<span class="token comment">// 在大多数情况下，应当避免使用 ref 这样的命令式代码。</span>
<span class="token comment">// useImperativeHandle 应当与 forwardRef 一起使用：</span>
<span class="token keyword">function</span> <span class="token function">FancyInput</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">focus</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      inputRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputRef<span class="token punctuation">}</span> <span class="token operator">...</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
FancyInput <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span>FancyInput<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 在 渲染 &lt;FancyInput ref={inputRef} /&gt; 的父组件可以调用 inputRef.current.focus()。</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>useLayoutEffect：尽可能使用标准的 useEffect 以避免阻塞视觉更新。</li></ol><p>说明：其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p><ol start="6"><li>useDebugValue：用于在 React 开发者工具中显示自定义 hook 的标签。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useFriendStatus</span><span class="token punctuation">(</span><span class="token parameter">friendID</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isOnline<span class="token punctuation">,</span> setIsOnline<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 在开发者工具中的这个 Hook 旁边显示标签</span>
  <span class="token comment">// e.g. &quot;FriendStatus: Online&quot;</span>
  <span class="token function">useDebugValue</span><span class="token punctuation">(</span>isOnline <span class="token operator">?</span> <span class="token string">&#39;Online&#39;</span> <span class="token operator">:</span> <span class="token string">&#39;Offline&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> isOnline<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="react原理" tabindex="-1"><a class="header-anchor" href="#react原理" aria-hidden="true">#</a> React原理</h3><ul><li>虚拟 DOM</li><li>组件化和声明式编程</li><li>Reconciliation（协调）</li></ul><h3 id="react的diff算法是怎么完成的" tabindex="-1"><a class="header-anchor" href="#react的diff算法是怎么完成的" aria-hidden="true">#</a> React的diff算法是怎么完成的</h3><ol><li>把树形结构按照层级分解，只比较同级元素。</li><li>通过给列表结构的每个单元添加的唯一 key值进行区分同层次的子节点的比较。</li><li>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</li><li>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty。到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制。</li><li>选择性渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</li></ol><h3 id="redux" tabindex="-1"><a class="header-anchor" href="#redux" aria-hidden="true">#</a> redux</h3><p>redux 的数据流：用户页面行为触发一个action（用到dispatch），然后store自动调用reducer，并传入两个参数，当前state和收到的action，reducer会返回一个新的state，每当state更新之后，view会根据state 触发重新渲染。 react-redux的实现原理：主要两个核心是</p><ul><li>Provider: 从最外面封装整个应用，并向connect模块传递store。</li><li>Connect: <ol><li>包装原组件，将state和action通过props的方式传入原组件内部。</li><li>监听store tree变化，使其包装的原组件可以响应state变化</li></ol></li></ul><p>redux异步中间件：redux-trunk， redux-saga 利用 applyMiddleware 将中间件添加到store上。</p>`,31),o=[p];function c(i,l){return a(),s("div",null,o)}const r=n(t,[["render",c],["__file","index.html.vue"]]);export{r as default};
